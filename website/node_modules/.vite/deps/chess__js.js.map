{
  "version": 3,
  "sources": ["../../chess.js/chess.js"],
  "sourcesContent": ["/*\r\n * Copyright (c) 2022, Jeff Hlywa (jhlywa@gmail.com)\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * 1. Redistributions of source code must retain the above copyright notice,\r\n *    this list of conditions and the following disclaimer.\r\n * 2. Redistributions in binary form must reproduce the above copyright notice,\r\n *    this list of conditions and the following disclaimer in the documentation\r\n *    and/or other materials provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\r\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n *----------------------------------------------------------------------------*/\r\n\r\nconst SYMBOLS = 'pnbrqkPNBRQK'\r\n\r\nconst DEFAULT_POSITION =\r\n  'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'\r\n\r\nconst TERMINATION_MARKERS = ['1-0', '0-1', '1/2-1/2', '*']\r\n\r\nconst PAWN_OFFSETS = {\r\n  b: [16, 32, 17, 15],\r\n  w: [-16, -32, -17, -15],\r\n}\r\n\r\nconst PIECE_OFFSETS = {\r\n  n: [-18, -33, -31, -14, 18, 33, 31, 14],\r\n  b: [-17, -15, 17, 15],\r\n  r: [-16, 1, 16, -1],\r\n  q: [-17, -16, -15, 1, 17, 16, 15, -1],\r\n  k: [-17, -16, -15, 1, 17, 16, 15, -1],\r\n}\r\n\r\n// prettier-ignore\r\nconst ATTACKS = [\r\n  20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20, 0,\r\n   0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,\r\n   0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,\r\n   0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,\r\n   0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,\r\n   0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,\r\n   0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\r\n  24,24,24,24,24,24,56,  0, 56,24,24,24,24,24,24, 0,\r\n   0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\r\n   0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,\r\n   0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,\r\n   0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,\r\n   0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,\r\n   0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,\r\n  20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20\r\n];\r\n\r\n// prettier-ignore\r\nconst RAYS = [\r\n   17,  0,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0,  0, 15, 0,\r\n    0, 17,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0, 15,  0, 0,\r\n    0,  0, 17,  0,  0,  0,  0, 16,  0,  0,  0,  0, 15,  0,  0, 0,\r\n    0,  0,  0, 17,  0,  0,  0, 16,  0,  0,  0, 15,  0,  0,  0, 0,\r\n    0,  0,  0,  0, 17,  0,  0, 16,  0,  0, 15,  0,  0,  0,  0, 0,\r\n    0,  0,  0,  0,  0, 17,  0, 16,  0, 15,  0,  0,  0,  0,  0, 0,\r\n    0,  0,  0,  0,  0,  0, 17, 16, 15,  0,  0,  0,  0,  0,  0, 0,\r\n    1,  1,  1,  1,  1,  1,  1,  0, -1, -1,  -1,-1, -1, -1, -1, 0,\r\n    0,  0,  0,  0,  0,  0,-15,-16,-17,  0,  0,  0,  0,  0,  0, 0,\r\n    0,  0,  0,  0,  0,-15,  0,-16,  0,-17,  0,  0,  0,  0,  0, 0,\r\n    0,  0,  0,  0,-15,  0,  0,-16,  0,  0,-17,  0,  0,  0,  0, 0,\r\n    0,  0,  0,-15,  0,  0,  0,-16,  0,  0,  0,-17,  0,  0,  0, 0,\r\n    0,  0,-15,  0,  0,  0,  0,-16,  0,  0,  0,  0,-17,  0,  0, 0,\r\n    0,-15,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,-17,  0, 0,\r\n  -15,  0,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,  0,-17\r\n];\r\n\r\nconst SHIFTS = { p: 0, n: 1, b: 2, r: 3, q: 4, k: 5 }\r\n\r\nconst BITS = {\r\n  NORMAL: 1,\r\n  CAPTURE: 2,\r\n  BIG_PAWN: 4,\r\n  EP_CAPTURE: 8,\r\n  PROMOTION: 16,\r\n  KSIDE_CASTLE: 32,\r\n  QSIDE_CASTLE: 64,\r\n}\r\n\r\nconst RANK_1 = 7\r\nconst RANK_2 = 6\r\nconst RANK_3 = 5\r\nconst RANK_4 = 4\r\nconst RANK_5 = 3\r\nconst RANK_6 = 2\r\nconst RANK_7 = 1\r\nconst RANK_8 = 0\r\n\r\n// prettier-ignore\r\nconst SQUARE_MAP = {\r\n  a8:   0, b8:   1, c8:   2, d8:   3, e8:   4, f8:   5, g8:   6, h8:   7,\r\n  a7:  16, b7:  17, c7:  18, d7:  19, e7:  20, f7:  21, g7:  22, h7:  23,\r\n  a6:  32, b6:  33, c6:  34, d6:  35, e6:  36, f6:  37, g6:  38, h6:  39,\r\n  a5:  48, b5:  49, c5:  50, d5:  51, e5:  52, f5:  53, g5:  54, h5:  55,\r\n  a4:  64, b4:  65, c4:  66, d4:  67, e4:  68, f4:  69, g4:  70, h4:  71,\r\n  a3:  80, b3:  81, c3:  82, d3:  83, e3:  84, f3:  85, g3:  86, h3:  87,\r\n  a2:  96, b2:  97, c2:  98, d2:  99, e2: 100, f2: 101, g2: 102, h2: 103,\r\n  a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\r\n};\r\n\r\nconst ROOKS = {\r\n  w: [\r\n    { square: SQUARE_MAP.a1, flag: BITS.QSIDE_CASTLE },\r\n    { square: SQUARE_MAP.h1, flag: BITS.KSIDE_CASTLE },\r\n  ],\r\n  b: [\r\n    { square: SQUARE_MAP.a8, flag: BITS.QSIDE_CASTLE },\r\n    { square: SQUARE_MAP.h8, flag: BITS.KSIDE_CASTLE },\r\n  ],\r\n}\r\n\r\nconst PARSER_STRICT = 0\r\nconst PARSER_SLOPPY = 1\r\n\r\n/* this function is used to uniquely identify ambiguous moves */\r\nfunction get_disambiguator(move, moves) {\r\n  var from = move.from\r\n  var to = move.to\r\n  var piece = move.piece\r\n\r\n  var ambiguities = 0\r\n  var same_rank = 0\r\n  var same_file = 0\r\n\r\n  for (var i = 0, len = moves.length; i < len; i++) {\r\n    var ambig_from = moves[i].from\r\n    var ambig_to = moves[i].to\r\n    var ambig_piece = moves[i].piece\r\n\r\n    /* if a move of the same piece type ends on the same to square, we'll\r\n     * need to add a disambiguator to the algebraic notation\r\n     */\r\n    if (piece === ambig_piece && from !== ambig_from && to === ambig_to) {\r\n      ambiguities++\r\n\r\n      if (rank(from) === rank(ambig_from)) {\r\n        same_rank++\r\n      }\r\n\r\n      if (file(from) === file(ambig_from)) {\r\n        same_file++\r\n      }\r\n    }\r\n  }\r\n\r\n  if (ambiguities > 0) {\r\n    /* if there exists a similar moving piece on the same rank and file as\r\n     * the move in question, use the square as the disambiguator\r\n     */\r\n    if (same_rank > 0 && same_file > 0) {\r\n      return algebraic(from)\r\n    } else if (same_file > 0) {\r\n      /* if the moving piece rests on the same file, use the rank symbol as the\r\n       * disambiguator\r\n       */\r\n      return algebraic(from).charAt(1)\r\n    } else {\r\n      /* else use the file symbol */\r\n      return algebraic(from).charAt(0)\r\n    }\r\n  }\r\n\r\n  return ''\r\n}\r\n\r\nfunction infer_piece_type(san) {\r\n  var piece_type = san.charAt(0)\r\n  if (piece_type >= 'a' && piece_type <= 'h') {\r\n    var matches = san.match(/[a-h]\\d.*[a-h]\\d/)\r\n    if (matches) {\r\n      return undefined\r\n    }\r\n    return PAWN\r\n  }\r\n  piece_type = piece_type.toLowerCase()\r\n  if (piece_type === 'o') {\r\n    return KING\r\n  }\r\n  return piece_type\r\n}\r\n\r\n// parses all of the decorators out of a SAN string\r\nfunction stripped_san(move) {\r\n  return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '')\r\n}\r\n\r\n/*****************************************************************************\r\n * UTILITY FUNCTIONS\r\n ****************************************************************************/\r\nfunction rank(i) {\r\n  return i >> 4\r\n}\r\n\r\nfunction file(i) {\r\n  return i & 15\r\n}\r\n\r\nfunction algebraic(i) {\r\n  var f = file(i),\r\n    r = rank(i)\r\n  return 'abcdefgh'.substring(f, f + 1) + '87654321'.substring(r, r + 1)\r\n}\r\n\r\nfunction swap_color(c) {\r\n  return c === WHITE ? BLACK : WHITE\r\n}\r\n\r\nfunction is_digit(c) {\r\n  return '0123456789'.indexOf(c) !== -1\r\n}\r\n\r\nfunction clone(obj) {\r\n  var dupe = obj instanceof Array ? [] : {}\r\n\r\n  for (var property in obj) {\r\n    if (typeof property === 'object') {\r\n      dupe[property] = clone(obj[property])\r\n    } else {\r\n      dupe[property] = obj[property]\r\n    }\r\n  }\r\n\r\n  return dupe\r\n}\r\n\r\nfunction trim(str) {\r\n  return str.replace(/^\\s+|\\s+$/g, '')\r\n}\r\n\r\n/***************************************************************************\r\n * PUBLIC CONSTANTS\r\n **************************************************************************/\r\n\r\nexport const BLACK = 'b'\r\nexport const WHITE = 'w'\r\n\r\nexport const EMPTY = -1\r\n\r\nexport const PAWN = 'p'\r\nexport const KNIGHT = 'n'\r\nexport const BISHOP = 'b'\r\nexport const ROOK = 'r'\r\nexport const QUEEN = 'q'\r\nexport const KING = 'k'\r\n\r\nexport const SQUARES = (function () {\r\n  /* from the ECMA-262 spec (section 12.6.4):\r\n   * \"The mechanics of enumerating the properties ... is\r\n   * implementation dependent\"\r\n   * so: for (var sq in SQUARES) { keys.push(sq); } might not be\r\n   * ordered correctly\r\n   */\r\n  var keys = []\r\n  for (var i = SQUARE_MAP.a8; i <= SQUARE_MAP.h1; i++) {\r\n    if (i & 0x88) {\r\n      i += 7\r\n      continue\r\n    }\r\n    keys.push(algebraic(i))\r\n  }\r\n  return keys\r\n})()\r\n\r\nexport const FLAGS = {\r\n  NORMAL: 'n',\r\n  CAPTURE: 'c',\r\n  BIG_PAWN: 'b',\r\n  EP_CAPTURE: 'e',\r\n  PROMOTION: 'p',\r\n  KSIDE_CASTLE: 'k',\r\n  QSIDE_CASTLE: 'q',\r\n}\r\n\r\nexport const Chess = function (fen) {\r\n  var board = new Array(128)\r\n  var kings = { w: EMPTY, b: EMPTY }\r\n  var turn = WHITE\r\n  var castling = { w: 0, b: 0 }\r\n  var ep_square = EMPTY\r\n  var half_moves = 0\r\n  var move_number = 1\r\n  var history = []\r\n  var header = {}\r\n  var comments = {}\r\n\r\n  /* if the user passes in a fen string, load it, else default to\r\n   * starting position\r\n   */\r\n  if (typeof fen === 'undefined') {\r\n    load(DEFAULT_POSITION)\r\n  } else {\r\n    load(fen)\r\n  }\r\n\r\n  function clear(keep_headers) {\r\n    if (typeof keep_headers === 'undefined') {\r\n      keep_headers = false\r\n    }\r\n\r\n    board = new Array(128)\r\n    kings = { w: EMPTY, b: EMPTY }\r\n    turn = WHITE\r\n    castling = { w: 0, b: 0 }\r\n    ep_square = EMPTY\r\n    half_moves = 0\r\n    move_number = 1\r\n    history = []\r\n    if (!keep_headers) header = {}\r\n    comments = {}\r\n    update_setup(generate_fen())\r\n  }\r\n\r\n  function prune_comments() {\r\n    var reversed_history = []\r\n    var current_comments = {}\r\n    var copy_comment = function (fen) {\r\n      if (fen in comments) {\r\n        current_comments[fen] = comments[fen]\r\n      }\r\n    }\r\n    while (history.length > 0) {\r\n      reversed_history.push(undo_move())\r\n    }\r\n    copy_comment(generate_fen())\r\n    while (reversed_history.length > 0) {\r\n      make_move(reversed_history.pop())\r\n      copy_comment(generate_fen())\r\n    }\r\n    comments = current_comments\r\n  }\r\n\r\n  function reset() {\r\n    load(DEFAULT_POSITION)\r\n  }\r\n\r\n  function load(fen, keep_headers) {\r\n    if (typeof keep_headers === 'undefined') {\r\n      keep_headers = false\r\n    }\r\n\r\n    var tokens = fen.split(/\\s+/)\r\n    var position = tokens[0]\r\n    var square = 0\r\n\r\n    if (!validate_fen(fen).valid) {\r\n      return false\r\n    }\r\n\r\n    clear(keep_headers)\r\n\r\n    for (var i = 0; i < position.length; i++) {\r\n      var piece = position.charAt(i)\r\n\r\n      if (piece === '/') {\r\n        square += 8\r\n      } else if (is_digit(piece)) {\r\n        square += parseInt(piece, 10)\r\n      } else {\r\n        var color = piece < 'a' ? WHITE : BLACK\r\n        put({ type: piece.toLowerCase(), color: color }, algebraic(square))\r\n        square++\r\n      }\r\n    }\r\n\r\n    turn = tokens[1]\r\n\r\n    if (tokens[2].indexOf('K') > -1) {\r\n      castling.w |= BITS.KSIDE_CASTLE\r\n    }\r\n    if (tokens[2].indexOf('Q') > -1) {\r\n      castling.w |= BITS.QSIDE_CASTLE\r\n    }\r\n    if (tokens[2].indexOf('k') > -1) {\r\n      castling.b |= BITS.KSIDE_CASTLE\r\n    }\r\n    if (tokens[2].indexOf('q') > -1) {\r\n      castling.b |= BITS.QSIDE_CASTLE\r\n    }\r\n\r\n    ep_square = tokens[3] === '-' ? EMPTY : SQUARE_MAP[tokens[3]]\r\n    half_moves = parseInt(tokens[4], 10)\r\n    move_number = parseInt(tokens[5], 10)\r\n\r\n    update_setup(generate_fen())\r\n\r\n    return true\r\n  }\r\n\r\n  /* TODO: this function is pretty much crap - it validates structure but\r\n   * completely ignores content (e.g. doesn't verify that each side has a king)\r\n   * ... we should rewrite this, and ditch the silly error_number field while\r\n   * we're at it\r\n   */\r\n  function validate_fen(fen) {\r\n    var errors = {\r\n      0: 'No errors.',\r\n      1: 'FEN string must contain six space-delimited fields.',\r\n      2: '6th field (move number) must be a positive integer.',\r\n      3: '5th field (half move counter) must be a non-negative integer.',\r\n      4: '4th field (en-passant square) is invalid.',\r\n      5: '3rd field (castling availability) is invalid.',\r\n      6: '2nd field (side to move) is invalid.',\r\n      7: \"1st field (piece positions) does not contain 8 '/'-delimited rows.\",\r\n      8: '1st field (piece positions) is invalid [consecutive numbers].',\r\n      9: '1st field (piece positions) is invalid [invalid piece].',\r\n      10: '1st field (piece positions) is invalid [row too large].',\r\n      11: 'Illegal en-passant square',\r\n    }\r\n\r\n    /* 1st criterion: 6 space-seperated fields? */\r\n    var tokens = fen.split(/\\s+/)\r\n    if (tokens.length !== 6) {\r\n      return { valid: false, error_number: 1, error: errors[1] }\r\n    }\r\n\r\n    /* 2nd criterion: move number field is a integer value > 0? */\r\n    if (isNaN(parseInt(tokens[5])) || parseInt(tokens[5], 10) <= 0) {\r\n      return { valid: false, error_number: 2, error: errors[2] }\r\n    }\r\n\r\n    /* 3rd criterion: half move counter is an integer >= 0? */\r\n    if (isNaN(parseInt(tokens[4])) || parseInt(tokens[4], 10) < 0) {\r\n      return { valid: false, error_number: 3, error: errors[3] }\r\n    }\r\n\r\n    /* 4th criterion: 4th field is a valid e.p.-string? */\r\n    if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\r\n      return { valid: false, error_number: 4, error: errors[4] }\r\n    }\r\n\r\n    /* 5th criterion: 3th field is a valid castle-string? */\r\n    if (!/^(KQ?k?q?|Qk?q?|kq?|q|-)$/.test(tokens[2])) {\r\n      return { valid: false, error_number: 5, error: errors[5] }\r\n    }\r\n\r\n    /* 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)? */\r\n    if (!/^(w|b)$/.test(tokens[1])) {\r\n      return { valid: false, error_number: 6, error: errors[6] }\r\n    }\r\n\r\n    /* 7th criterion: 1st field contains 8 rows? */\r\n    var rows = tokens[0].split('/')\r\n    if (rows.length !== 8) {\r\n      return { valid: false, error_number: 7, error: errors[7] }\r\n    }\r\n\r\n    /* 8th criterion: every row is valid? */\r\n    for (var i = 0; i < rows.length; i++) {\r\n      /* check for right sum of fields AND not two numbers in succession */\r\n      var sum_fields = 0\r\n      var previous_was_number = false\r\n\r\n      for (var k = 0; k < rows[i].length; k++) {\r\n        if (!isNaN(rows[i][k])) {\r\n          if (previous_was_number) {\r\n            return { valid: false, error_number: 8, error: errors[8] }\r\n          }\r\n          sum_fields += parseInt(rows[i][k], 10)\r\n          previous_was_number = true\r\n        } else {\r\n          if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\r\n            return { valid: false, error_number: 9, error: errors[9] }\r\n          }\r\n          sum_fields += 1\r\n          previous_was_number = false\r\n        }\r\n      }\r\n      if (sum_fields !== 8) {\r\n        return { valid: false, error_number: 10, error: errors[10] }\r\n      }\r\n    }\r\n\r\n    if (\r\n      (tokens[3][1] == '3' && tokens[1] == 'w') ||\r\n      (tokens[3][1] == '6' && tokens[1] == 'b')\r\n    ) {\r\n      return { valid: false, error_number: 11, error: errors[11] }\r\n    }\r\n\r\n    /* everything's okay! */\r\n    return { valid: true, error_number: 0, error: errors[0] }\r\n  }\r\n\r\n  function generate_fen() {\r\n    var empty = 0\r\n    var fen = ''\r\n\r\n    for (var i = SQUARE_MAP.a8; i <= SQUARE_MAP.h1; i++) {\r\n      if (board[i] == null) {\r\n        empty++\r\n      } else {\r\n        if (empty > 0) {\r\n          fen += empty\r\n          empty = 0\r\n        }\r\n        var color = board[i].color\r\n        var piece = board[i].type\r\n\r\n        fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase()\r\n      }\r\n\r\n      if ((i + 1) & 0x88) {\r\n        if (empty > 0) {\r\n          fen += empty\r\n        }\r\n\r\n        if (i !== SQUARE_MAP.h1) {\r\n          fen += '/'\r\n        }\r\n\r\n        empty = 0\r\n        i += 8\r\n      }\r\n    }\r\n\r\n    var cflags = ''\r\n    if (castling[WHITE] & BITS.KSIDE_CASTLE) {\r\n      cflags += 'K'\r\n    }\r\n    if (castling[WHITE] & BITS.QSIDE_CASTLE) {\r\n      cflags += 'Q'\r\n    }\r\n    if (castling[BLACK] & BITS.KSIDE_CASTLE) {\r\n      cflags += 'k'\r\n    }\r\n    if (castling[BLACK] & BITS.QSIDE_CASTLE) {\r\n      cflags += 'q'\r\n    }\r\n\r\n    /* do we have an empty castling flag? */\r\n    cflags = cflags || '-'\r\n    var epflags = ep_square === EMPTY ? '-' : algebraic(ep_square)\r\n\r\n    return [fen, turn, cflags, epflags, half_moves, move_number].join(' ')\r\n  }\r\n\r\n  function set_header(args) {\r\n    for (var i = 0; i < args.length; i += 2) {\r\n      if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\r\n        header[args[i]] = args[i + 1]\r\n      }\r\n    }\r\n    return header\r\n  }\r\n\r\n  /* called when the initial board setup is changed with put() or remove().\r\n   * modifies the SetUp and FEN properties of the header object.  if the FEN is\r\n   * equal to the default position, the SetUp and FEN are deleted\r\n   * the setup is only updated if history.length is zero, ie moves haven't been\r\n   * made.\r\n   */\r\n  function update_setup(fen) {\r\n    if (history.length > 0) return\r\n\r\n    if (fen !== DEFAULT_POSITION) {\r\n      header['SetUp'] = '1'\r\n      header['FEN'] = fen\r\n    } else {\r\n      delete header['SetUp']\r\n      delete header['FEN']\r\n    }\r\n  }\r\n\r\n  function get(square) {\r\n    var piece = board[SQUARE_MAP[square]]\r\n    return piece ? { type: piece.type, color: piece.color } : null\r\n  }\r\n\r\n  function put(piece, square) {\r\n    /* check for valid piece object */\r\n    if (!('type' in piece && 'color' in piece)) {\r\n      return false\r\n    }\r\n\r\n    /* check for piece */\r\n    if (SYMBOLS.indexOf(piece.type.toLowerCase()) === -1) {\r\n      return false\r\n    }\r\n\r\n    /* check for valid square */\r\n    if (!(square in SQUARE_MAP)) {\r\n      return false\r\n    }\r\n\r\n    var sq = SQUARE_MAP[square]\r\n\r\n    /* don't let the user place more than one king */\r\n    if (\r\n      piece.type == KING &&\r\n      !(kings[piece.color] == EMPTY || kings[piece.color] == sq)\r\n    ) {\r\n      return false\r\n    }\r\n\r\n    board[sq] = { type: piece.type, color: piece.color }\r\n    if (piece.type === KING) {\r\n      kings[piece.color] = sq\r\n    }\r\n\r\n    update_setup(generate_fen())\r\n\r\n    return true\r\n  }\r\n\r\n  function remove(square) {\r\n    var piece = get(square)\r\n    board[SQUARE_MAP[square]] = null\r\n    if (piece && piece.type === KING) {\r\n      kings[piece.color] = EMPTY\r\n    }\r\n\r\n    update_setup(generate_fen())\r\n\r\n    return piece\r\n  }\r\n\r\n  function build_move(board, from, to, flags, promotion) {\r\n    var move = {\r\n      color: turn,\r\n      from: from,\r\n      to: to,\r\n      flags: flags,\r\n      piece: board[from].type,\r\n    }\r\n\r\n    if (promotion) {\r\n      move.flags |= BITS.PROMOTION\r\n      move.promotion = promotion\r\n    }\r\n\r\n    if (board[to]) {\r\n      move.captured = board[to].type\r\n    } else if (flags & BITS.EP_CAPTURE) {\r\n      move.captured = PAWN\r\n    }\r\n    return move\r\n  }\r\n\r\n  function generate_moves(options) {\r\n    function add_move(board, moves, from, to, flags) {\r\n      /* if pawn promotion */\r\n      if (\r\n        board[from].type === PAWN &&\r\n        (rank(to) === RANK_8 || rank(to) === RANK_1)\r\n      ) {\r\n        var pieces = [QUEEN, ROOK, BISHOP, KNIGHT]\r\n        for (var i = 0, len = pieces.length; i < len; i++) {\r\n          moves.push(build_move(board, from, to, flags, pieces[i]))\r\n        }\r\n      } else {\r\n        moves.push(build_move(board, from, to, flags))\r\n      }\r\n    }\r\n\r\n    var moves = []\r\n    var us = turn\r\n    var them = swap_color(us)\r\n    var second_rank = { b: RANK_7, w: RANK_2 }\r\n\r\n    var first_sq = SQUARE_MAP.a8\r\n    var last_sq = SQUARE_MAP.h1\r\n    var single_square = false\r\n\r\n    /* do we want legal moves? */\r\n    var legal =\r\n      typeof options !== 'undefined' && 'legal' in options\r\n        ? options.legal\r\n        : true\r\n\r\n    var piece_type =\r\n      typeof options !== 'undefined' &&\r\n      'piece' in options &&\r\n      typeof options.piece === 'string'\r\n        ? options.piece.toLowerCase()\r\n        : true\r\n\r\n    /* are we generating moves for a single square? */\r\n    if (typeof options !== 'undefined' && 'square' in options) {\r\n      if (options.square in SQUARE_MAP) {\r\n        first_sq = last_sq = SQUARE_MAP[options.square]\r\n        single_square = true\r\n      } else {\r\n        /* invalid square */\r\n        return []\r\n      }\r\n    }\r\n\r\n    for (var i = first_sq; i <= last_sq; i++) {\r\n      /* did we run off the end of the board */\r\n      if (i & 0x88) {\r\n        i += 7\r\n        continue\r\n      }\r\n\r\n      var piece = board[i]\r\n      if (piece == null || piece.color !== us) {\r\n        continue\r\n      }\r\n\r\n      if (piece.type === PAWN && (piece_type === true || piece_type === PAWN)) {\r\n        /* single square, non-capturing */\r\n        var square = i + PAWN_OFFSETS[us][0]\r\n        if (board[square] == null) {\r\n          add_move(board, moves, i, square, BITS.NORMAL)\r\n\r\n          /* double square */\r\n          var square = i + PAWN_OFFSETS[us][1]\r\n          if (second_rank[us] === rank(i) && board[square] == null) {\r\n            add_move(board, moves, i, square, BITS.BIG_PAWN)\r\n          }\r\n        }\r\n\r\n        /* pawn captures */\r\n        for (j = 2; j < 4; j++) {\r\n          var square = i + PAWN_OFFSETS[us][j]\r\n          if (square & 0x88) continue\r\n\r\n          if (board[square] != null && board[square].color === them) {\r\n            add_move(board, moves, i, square, BITS.CAPTURE)\r\n          } else if (square === ep_square) {\r\n            add_move(board, moves, i, ep_square, BITS.EP_CAPTURE)\r\n          }\r\n        }\r\n      } else if (piece_type === true || piece_type === piece.type) {\r\n        for (var j = 0, len = PIECE_OFFSETS[piece.type].length; j < len; j++) {\r\n          var offset = PIECE_OFFSETS[piece.type][j]\r\n          var square = i\r\n\r\n          while (true) {\r\n            square += offset\r\n            if (square & 0x88) break\r\n\r\n            if (board[square] == null) {\r\n              add_move(board, moves, i, square, BITS.NORMAL)\r\n            } else {\r\n              if (board[square].color === us) break\r\n              add_move(board, moves, i, square, BITS.CAPTURE)\r\n              break\r\n            }\r\n\r\n            /* break, if knight or king */\r\n            if (piece.type === 'n' || piece.type === 'k') break\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    /* check for castling if: a) we're generating all moves, or b) we're doing\r\n     * single square move generation on the king's square\r\n     */\r\n    if (piece_type === true || piece_type === KING) {\r\n      if (!single_square || last_sq === kings[us]) {\r\n        /* king-side castling */\r\n        if (castling[us] & BITS.KSIDE_CASTLE) {\r\n          var castling_from = kings[us]\r\n          var castling_to = castling_from + 2\r\n\r\n          if (\r\n            board[castling_from + 1] == null &&\r\n            board[castling_to] == null &&\r\n            !attacked(them, kings[us]) &&\r\n            !attacked(them, castling_from + 1) &&\r\n            !attacked(them, castling_to)\r\n          ) {\r\n            add_move(board, moves, kings[us], castling_to, BITS.KSIDE_CASTLE)\r\n          }\r\n        }\r\n\r\n        /* queen-side castling */\r\n        if (castling[us] & BITS.QSIDE_CASTLE) {\r\n          var castling_from = kings[us]\r\n          var castling_to = castling_from - 2\r\n\r\n          if (\r\n            board[castling_from - 1] == null &&\r\n            board[castling_from - 2] == null &&\r\n            board[castling_from - 3] == null &&\r\n            !attacked(them, kings[us]) &&\r\n            !attacked(them, castling_from - 1) &&\r\n            !attacked(them, castling_to)\r\n          ) {\r\n            add_move(board, moves, kings[us], castling_to, BITS.QSIDE_CASTLE)\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    /* return all pseudo-legal moves (this includes moves that allow the king\r\n     * to be captured)\r\n     */\r\n    if (!legal) {\r\n      return moves\r\n    }\r\n\r\n    /* filter out illegal moves */\r\n    var legal_moves = []\r\n    for (var i = 0, len = moves.length; i < len; i++) {\r\n      make_move(moves[i])\r\n      if (!king_attacked(us)) {\r\n        legal_moves.push(moves[i])\r\n      }\r\n      undo_move()\r\n    }\r\n\r\n    return legal_moves\r\n  }\r\n\r\n  /* convert a move from 0x88 coordinates to Standard Algebraic Notation\r\n   * (SAN)\r\n   *\r\n   * @param {boolean} sloppy Use the sloppy SAN generator to work around over\r\n   * disambiguation bugs in Fritz and Chessbase.  See below:\r\n   *\r\n   * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\r\n   * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\r\n   * 4. ... Ne7 is technically the valid SAN\r\n   */\r\n  function move_to_san(move, moves) {\r\n    var output = ''\r\n\r\n    if (move.flags & BITS.KSIDE_CASTLE) {\r\n      output = 'O-O'\r\n    } else if (move.flags & BITS.QSIDE_CASTLE) {\r\n      output = 'O-O-O'\r\n    } else {\r\n      if (move.piece !== PAWN) {\r\n        var disambiguator = get_disambiguator(move, moves)\r\n        output += move.piece.toUpperCase() + disambiguator\r\n      }\r\n\r\n      if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\r\n        if (move.piece === PAWN) {\r\n          output += algebraic(move.from)[0]\r\n        }\r\n        output += 'x'\r\n      }\r\n\r\n      output += algebraic(move.to)\r\n\r\n      if (move.flags & BITS.PROMOTION) {\r\n        output += '=' + move.promotion.toUpperCase()\r\n      }\r\n    }\r\n\r\n    make_move(move)\r\n    if (in_check()) {\r\n      if (in_checkmate()) {\r\n        output += '#'\r\n      } else {\r\n        output += '+'\r\n      }\r\n    }\r\n    undo_move()\r\n\r\n    return output\r\n  }\r\n\r\n  function attacked(color, square) {\r\n    for (var i = SQUARE_MAP.a8; i <= SQUARE_MAP.h1; i++) {\r\n      /* did we run off the end of the board */\r\n      if (i & 0x88) {\r\n        i += 7\r\n        continue\r\n      }\r\n\r\n      /* if empty square or wrong color */\r\n      if (board[i] == null || board[i].color !== color) continue\r\n\r\n      var piece = board[i]\r\n      var difference = i - square\r\n      var index = difference + 119\r\n\r\n      if (ATTACKS[index] & (1 << SHIFTS[piece.type])) {\r\n        if (piece.type === PAWN) {\r\n          if (difference > 0) {\r\n            if (piece.color === WHITE) return true\r\n          } else {\r\n            if (piece.color === BLACK) return true\r\n          }\r\n          continue\r\n        }\r\n\r\n        /* if the piece is a knight or a king */\r\n        if (piece.type === 'n' || piece.type === 'k') return true\r\n\r\n        var offset = RAYS[index]\r\n        var j = i + offset\r\n\r\n        var blocked = false\r\n        while (j !== square) {\r\n          if (board[j] != null) {\r\n            blocked = true\r\n            break\r\n          }\r\n          j += offset\r\n        }\r\n\r\n        if (!blocked) return true\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r\n\r\n  function king_attacked(color) {\r\n    return attacked(swap_color(color), kings[color])\r\n  }\r\n\r\n  function in_check() {\r\n    return king_attacked(turn)\r\n  }\r\n\r\n  function in_checkmate() {\r\n    return in_check() && generate_moves().length === 0\r\n  }\r\n\r\n  function in_stalemate() {\r\n    return !in_check() && generate_moves().length === 0\r\n  }\r\n\r\n  function insufficient_material() {\r\n    var pieces = {}\r\n    var bishops = []\r\n    var num_pieces = 0\r\n    var sq_color = 0\r\n\r\n    for (var i = SQUARE_MAP.a8; i <= SQUARE_MAP.h1; i++) {\r\n      sq_color = (sq_color + 1) % 2\r\n      if (i & 0x88) {\r\n        i += 7\r\n        continue\r\n      }\r\n\r\n      var piece = board[i]\r\n      if (piece) {\r\n        pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1\r\n        if (piece.type === BISHOP) {\r\n          bishops.push(sq_color)\r\n        }\r\n        num_pieces++\r\n      }\r\n    }\r\n\r\n    /* k vs. k */\r\n    if (num_pieces === 2) {\r\n      return true\r\n    } else if (\r\n      /* k vs. kn .... or .... k vs. kb */\r\n      num_pieces === 3 &&\r\n      (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)\r\n    ) {\r\n      return true\r\n    } else if (num_pieces === pieces[BISHOP] + 2) {\r\n      /* kb vs. kb where any number of bishops are all on the same color */\r\n      var sum = 0\r\n      var len = bishops.length\r\n      for (var i = 0; i < len; i++) {\r\n        sum += bishops[i]\r\n      }\r\n      if (sum === 0 || sum === len) {\r\n        return true\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r\n\r\n  function in_threefold_repetition() {\r\n    /* TODO: while this function is fine for casual use, a better\r\n     * implementation would use a Zobrist key (instead of FEN). the\r\n     * Zobrist key would be maintained in the make_move/undo_move functions,\r\n     * avoiding the costly that we do below.\r\n     */\r\n    var moves = []\r\n    var positions = {}\r\n    var repetition = false\r\n\r\n    while (true) {\r\n      var move = undo_move()\r\n      if (!move) break\r\n      moves.push(move)\r\n    }\r\n\r\n    while (true) {\r\n      /* remove the last two fields in the FEN string, they're not needed\r\n       * when checking for draw by rep */\r\n      var fen = generate_fen().split(' ').slice(0, 4).join(' ')\r\n\r\n      /* has the position occurred three or move times */\r\n      positions[fen] = fen in positions ? positions[fen] + 1 : 1\r\n      if (positions[fen] >= 3) {\r\n        repetition = true\r\n      }\r\n\r\n      if (!moves.length) {\r\n        break\r\n      }\r\n      make_move(moves.pop())\r\n    }\r\n\r\n    return repetition\r\n  }\r\n\r\n  function push(move) {\r\n    history.push({\r\n      move: move,\r\n      kings: { b: kings.b, w: kings.w },\r\n      turn: turn,\r\n      castling: { b: castling.b, w: castling.w },\r\n      ep_square: ep_square,\r\n      half_moves: half_moves,\r\n      move_number: move_number,\r\n    })\r\n  }\r\n\r\n  function make_move(move) {\r\n    var us = turn\r\n    var them = swap_color(us)\r\n    push(move)\r\n\r\n    board[move.to] = board[move.from]\r\n    board[move.from] = null\r\n\r\n    /* if ep capture, remove the captured pawn */\r\n    if (move.flags & BITS.EP_CAPTURE) {\r\n      if (turn === BLACK) {\r\n        board[move.to - 16] = null\r\n      } else {\r\n        board[move.to + 16] = null\r\n      }\r\n    }\r\n\r\n    /* if pawn promotion, replace with new piece */\r\n    if (move.flags & BITS.PROMOTION) {\r\n      board[move.to] = { type: move.promotion, color: us }\r\n    }\r\n\r\n    /* if we moved the king */\r\n    if (board[move.to].type === KING) {\r\n      kings[board[move.to].color] = move.to\r\n\r\n      /* if we castled, move the rook next to the king */\r\n      if (move.flags & BITS.KSIDE_CASTLE) {\r\n        var castling_to = move.to - 1\r\n        var castling_from = move.to + 1\r\n        board[castling_to] = board[castling_from]\r\n        board[castling_from] = null\r\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\r\n        var castling_to = move.to + 1\r\n        var castling_from = move.to - 2\r\n        board[castling_to] = board[castling_from]\r\n        board[castling_from] = null\r\n      }\r\n\r\n      /* turn off castling */\r\n      castling[us] = ''\r\n    }\r\n\r\n    /* turn off castling if we move a rook */\r\n    if (castling[us]) {\r\n      for (var i = 0, len = ROOKS[us].length; i < len; i++) {\r\n        if (\r\n          move.from === ROOKS[us][i].square &&\r\n          castling[us] & ROOKS[us][i].flag\r\n        ) {\r\n          castling[us] ^= ROOKS[us][i].flag\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    /* turn off castling if we capture a rook */\r\n    if (castling[them]) {\r\n      for (var i = 0, len = ROOKS[them].length; i < len; i++) {\r\n        if (\r\n          move.to === ROOKS[them][i].square &&\r\n          castling[them] & ROOKS[them][i].flag\r\n        ) {\r\n          castling[them] ^= ROOKS[them][i].flag\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    /* if big pawn move, update the en passant square */\r\n    if (move.flags & BITS.BIG_PAWN) {\r\n      if (turn === 'b') {\r\n        ep_square = move.to - 16\r\n      } else {\r\n        ep_square = move.to + 16\r\n      }\r\n    } else {\r\n      ep_square = EMPTY\r\n    }\r\n\r\n    /* reset the 50 move counter if a pawn is moved or a piece is captured */\r\n    if (move.piece === PAWN) {\r\n      half_moves = 0\r\n    } else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\r\n      half_moves = 0\r\n    } else {\r\n      half_moves++\r\n    }\r\n\r\n    if (turn === BLACK) {\r\n      move_number++\r\n    }\r\n    turn = swap_color(turn)\r\n  }\r\n\r\n  function undo_move() {\r\n    var old = history.pop()\r\n    if (old == null) {\r\n      return null\r\n    }\r\n\r\n    var move = old.move\r\n    kings = old.kings\r\n    turn = old.turn\r\n    castling = old.castling\r\n    ep_square = old.ep_square\r\n    half_moves = old.half_moves\r\n    move_number = old.move_number\r\n\r\n    var us = turn\r\n    var them = swap_color(turn)\r\n\r\n    board[move.from] = board[move.to]\r\n    board[move.from].type = move.piece // to undo any promotions\r\n    board[move.to] = null\r\n\r\n    if (move.flags & BITS.CAPTURE) {\r\n      board[move.to] = { type: move.captured, color: them }\r\n    } else if (move.flags & BITS.EP_CAPTURE) {\r\n      var index\r\n      if (us === BLACK) {\r\n        index = move.to - 16\r\n      } else {\r\n        index = move.to + 16\r\n      }\r\n      board[index] = { type: PAWN, color: them }\r\n    }\r\n\r\n    if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\r\n      var castling_to, castling_from\r\n      if (move.flags & BITS.KSIDE_CASTLE) {\r\n        castling_to = move.to + 1\r\n        castling_from = move.to - 1\r\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\r\n        castling_to = move.to - 2\r\n        castling_from = move.to + 1\r\n      }\r\n\r\n      board[castling_to] = board[castling_from]\r\n      board[castling_from] = null\r\n    }\r\n\r\n    return move\r\n  }\r\n\r\n  // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\r\n  function move_from_san(move, sloppy) {\r\n    // strip off any move decorations: e.g Nf3+?! becomes Nf3\r\n    var clean_move = stripped_san(move)\r\n\r\n    // the move parsers is a 2-step state\r\n    for (var parser = 0; parser < 2; parser++) {\r\n      if (parser == PARSER_SLOPPY) {\r\n        // only run the sloppy parse if explicitly requested\r\n        if (!sloppy) {\r\n          return null\r\n        }\r\n\r\n        // The sloppy parser allows the user to parse non-standard chess\r\n        // notations. This parser is opt-in (by specifying the\r\n        // '{ sloppy: true }' setting) and is only run after the Standard\r\n        // Algebraic Notation (SAN) parser has failed.\r\n        //\r\n        // When running the sloppy parser, we'll run a regex to grab the piece,\r\n        // the to/from square, and an optional promotion piece. This regex will\r\n        // parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\r\n        // f7f8q, b1c3\r\n\r\n        // NOTE: Some positions and moves may be ambiguous when using the\r\n        // sloppy parser. For example, in this position:\r\n        // 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1, the move b1c3 may be interpreted\r\n        // as Nc3 or B1c3 (a disambiguated bishop move). In these cases, the\r\n        // sloppy parser will default to the most most basic interpretation\r\n        // (which is b1c3 parsing to Nc3).\r\n\r\n        // FIXME: these var's are hoisted into function scope, this will need\r\n        // to change when switching to const/let\r\n\r\n        var overly_disambiguated = false\r\n\r\n        var matches = clean_move.match(\r\n          /([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/\r\n        )\r\n        if (matches) {\r\n          var piece = matches[1]\r\n          var from = matches[2]\r\n          var to = matches[3]\r\n          var promotion = matches[4]\r\n\r\n          if (from.length == 1) {\r\n            overly_disambiguated = true\r\n          }\r\n        } else {\r\n          // The [a-h]?[1-8]? portion of the regex below handles moves that may\r\n          // be overly disambiguated (e.g. Nge7 is unnecessary and non-standard\r\n          // when there is one legal knight move to e7). In this case, the value\r\n          // of 'from' variable will be a rank or file, not a square.\r\n          var matches = clean_move.match(\r\n            /([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/\r\n          )\r\n\r\n          if (matches) {\r\n            var piece = matches[1]\r\n            var from = matches[2]\r\n            var to = matches[3]\r\n            var promotion = matches[4]\r\n\r\n            if (from.length == 1) {\r\n              var overly_disambiguated = true\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      var piece_type = infer_piece_type(clean_move)\r\n      var moves = generate_moves({\r\n        legal: true,\r\n        piece: piece ? piece : piece_type,\r\n      })\r\n\r\n      for (var i = 0, len = moves.length; i < len; i++) {\r\n        switch (parser) {\r\n          case PARSER_STRICT: {\r\n            if (clean_move === stripped_san(move_to_san(moves[i], moves))) {\r\n              return moves[i]\r\n            }\r\n            break\r\n          }\r\n          case PARSER_SLOPPY: {\r\n            if (matches) {\r\n              // hand-compare move properties with the results from our sloppy\r\n              // regex\r\n              if (\r\n                (!piece || piece.toLowerCase() == moves[i].piece) &&\r\n                SQUARE_MAP[from] == moves[i].from &&\r\n                SQUARE_MAP[to] == moves[i].to &&\r\n                (!promotion || promotion.toLowerCase() == moves[i].promotion)\r\n              ) {\r\n                return moves[i]\r\n              } else if (overly_disambiguated) {\r\n                // SPECIAL CASE: we parsed a move string that may have an\r\n                // unneeded rank/file disambiguator (e.g. Nge7).  The 'from'\r\n                // variable will\r\n                var square = algebraic(moves[i].from)\r\n                if (\r\n                  (!piece || piece.toLowerCase() == moves[i].piece) &&\r\n                  SQUARE_MAP[to] == moves[i].to &&\r\n                  (from == square[0] || from == square[1]) &&\r\n                  (!promotion || promotion.toLowerCase() == moves[i].promotion)\r\n                ) {\r\n                  return moves[i]\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return null\r\n  }\r\n\r\n  /* pretty = external move object */\r\n  function make_pretty(ugly_move) {\r\n    var move = clone(ugly_move)\r\n    move.san = move_to_san(move, generate_moves({ legal: true }))\r\n    move.to = algebraic(move.to)\r\n    move.from = algebraic(move.from)\r\n\r\n    var flags = ''\r\n\r\n    for (var flag in BITS) {\r\n      if (BITS[flag] & move.flags) {\r\n        flags += FLAGS[flag]\r\n      }\r\n    }\r\n    move.flags = flags\r\n\r\n    return move\r\n  }\r\n\r\n  /*****************************************************************************\r\n   * DEBUGGING UTILITIES\r\n   ****************************************************************************/\r\n  function perft(depth) {\r\n    var moves = generate_moves({ legal: false })\r\n    var nodes = 0\r\n    var color = turn\r\n\r\n    for (var i = 0, len = moves.length; i < len; i++) {\r\n      make_move(moves[i])\r\n      if (!king_attacked(color)) {\r\n        if (depth - 1 > 0) {\r\n          var child_nodes = perft(depth - 1)\r\n          nodes += child_nodes\r\n        } else {\r\n          nodes++\r\n        }\r\n      }\r\n      undo_move()\r\n    }\r\n\r\n    return nodes\r\n  }\r\n\r\n  return {\r\n    /***************************************************************************\r\n     * PUBLIC API\r\n     **************************************************************************/\r\n    load: function (fen) {\r\n      return load(fen)\r\n    },\r\n\r\n    reset: function () {\r\n      return reset()\r\n    },\r\n\r\n    moves: function (options) {\r\n      /* The internal representation of a chess move is in 0x88 format, and\r\n       * not meant to be human-readable.  The code below converts the 0x88\r\n       * square coordinates to algebraic coordinates.  It also prunes an\r\n       * unnecessary move keys resulting from a verbose call.\r\n       */\r\n\r\n      var ugly_moves = generate_moves(options)\r\n      var moves = []\r\n\r\n      for (var i = 0, len = ugly_moves.length; i < len; i++) {\r\n        /* does the user want a full move object (most likely not), or just\r\n         * SAN\r\n         */\r\n        if (\r\n          typeof options !== 'undefined' &&\r\n          'verbose' in options &&\r\n          options.verbose\r\n        ) {\r\n          moves.push(make_pretty(ugly_moves[i]))\r\n        } else {\r\n          moves.push(\r\n            move_to_san(ugly_moves[i], generate_moves({ legal: true }))\r\n          )\r\n        }\r\n      }\r\n\r\n      return moves\r\n    },\r\n\r\n    in_check: function () {\r\n      return in_check()\r\n    },\r\n\r\n    in_checkmate: function () {\r\n      return in_checkmate()\r\n    },\r\n\r\n    in_stalemate: function () {\r\n      return in_stalemate()\r\n    },\r\n\r\n    in_draw: function () {\r\n      return (\r\n        half_moves >= 100 ||\r\n        in_stalemate() ||\r\n        insufficient_material() ||\r\n        in_threefold_repetition()\r\n      )\r\n    },\r\n\r\n    insufficient_material: function () {\r\n      return insufficient_material()\r\n    },\r\n\r\n    in_threefold_repetition: function () {\r\n      return in_threefold_repetition()\r\n    },\r\n\r\n    game_over: function () {\r\n      return (\r\n        half_moves >= 100 ||\r\n        in_checkmate() ||\r\n        in_stalemate() ||\r\n        insufficient_material() ||\r\n        in_threefold_repetition()\r\n      )\r\n    },\r\n\r\n    validate_fen: function (fen) {\r\n      return validate_fen(fen)\r\n    },\r\n\r\n    fen: function () {\r\n      return generate_fen()\r\n    },\r\n\r\n    board: function () {\r\n      var output = [],\r\n        row = []\r\n\r\n      for (var i = SQUARE_MAP.a8; i <= SQUARE_MAP.h1; i++) {\r\n        if (board[i] == null) {\r\n          row.push(null)\r\n        } else {\r\n          row.push({\r\n            square: algebraic(i),\r\n            type: board[i].type,\r\n            color: board[i].color,\r\n          })\r\n        }\r\n        if ((i + 1) & 0x88) {\r\n          output.push(row)\r\n          row = []\r\n          i += 8\r\n        }\r\n      }\r\n\r\n      return output\r\n    },\r\n\r\n    pgn: function (options) {\r\n      /* using the specification from http://www.chessclub.com/help/PGN-spec\r\n       * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\r\n       */\r\n      var newline =\r\n        typeof options === 'object' && typeof options.newline_char === 'string'\r\n          ? options.newline_char\r\n          : '\\n'\r\n      var max_width =\r\n        typeof options === 'object' && typeof options.max_width === 'number'\r\n          ? options.max_width\r\n          : 0\r\n      var result = []\r\n      var header_exists = false\r\n\r\n      /* add the PGN header information */\r\n      for (var i in header) {\r\n        /* TODO: order of enumerated properties in header object is not\r\n         * guaranteed, see ECMA-262 spec (section 12.6.4)\r\n         */\r\n        result.push('[' + i + ' \"' + header[i] + '\"]' + newline)\r\n        header_exists = true\r\n      }\r\n\r\n      if (header_exists && history.length) {\r\n        result.push(newline)\r\n      }\r\n\r\n      var append_comment = function (move_string) {\r\n        var comment = comments[generate_fen()]\r\n        if (typeof comment !== 'undefined') {\r\n          var delimiter = move_string.length > 0 ? ' ' : ''\r\n          move_string = `${move_string}${delimiter}{${comment}}`\r\n        }\r\n        return move_string\r\n      }\r\n\r\n      /* pop all of history onto reversed_history */\r\n      var reversed_history = []\r\n      while (history.length > 0) {\r\n        reversed_history.push(undo_move())\r\n      }\r\n\r\n      var moves = []\r\n      var move_string = ''\r\n\r\n      /* special case of a commented starting position with no moves */\r\n      if (reversed_history.length === 0) {\r\n        moves.push(append_comment(''))\r\n      }\r\n\r\n      /* build the list of moves.  a move_string looks like: \"3. e3 e6\" */\r\n      while (reversed_history.length > 0) {\r\n        move_string = append_comment(move_string)\r\n        var move = reversed_history.pop()\r\n\r\n        /* if the position started with black to move, start PGN with #. ... */\r\n        if (!history.length && move.color === 'b') {\r\n          const prefix = `${move_number}. ...`\r\n          /* is there a comment preceding the first move? */\r\n          move_string = move_string ? `${move_string} ${prefix}` : prefix\r\n        } else if (move.color === 'w') {\r\n          /* store the previous generated move_string if we have one */\r\n          if (move_string.length) {\r\n            moves.push(move_string)\r\n          }\r\n          move_string = move_number + '.'\r\n        }\r\n\r\n        move_string =\r\n          move_string + ' ' + move_to_san(move, generate_moves({ legal: true }))\r\n        make_move(move)\r\n      }\r\n\r\n      /* are there any other leftover moves? */\r\n      if (move_string.length) {\r\n        moves.push(append_comment(move_string))\r\n      }\r\n\r\n      /* is there a result? */\r\n      if (typeof header.Result !== 'undefined') {\r\n        moves.push(header.Result)\r\n      }\r\n\r\n      /* history should be back to what it was before we started generating PGN,\r\n       * so join together moves\r\n       */\r\n      if (max_width === 0) {\r\n        return result.join('') + moves.join(' ')\r\n      }\r\n\r\n      var strip = function () {\r\n        if (result.length > 0 && result[result.length - 1] === ' ') {\r\n          result.pop()\r\n          return true\r\n        }\r\n        return false\r\n      }\r\n\r\n      /* NB: this does not preserve comment whitespace. */\r\n      var wrap_comment = function (width, move) {\r\n        for (var token of move.split(' ')) {\r\n          if (!token) {\r\n            continue\r\n          }\r\n          if (width + token.length > max_width) {\r\n            while (strip()) {\r\n              width--\r\n            }\r\n            result.push(newline)\r\n            width = 0\r\n          }\r\n          result.push(token)\r\n          width += token.length\r\n          result.push(' ')\r\n          width++\r\n        }\r\n        if (strip()) {\r\n          width--\r\n        }\r\n        return width\r\n      }\r\n\r\n      /* wrap the PGN output at max_width */\r\n      var current_width = 0\r\n      for (var i = 0; i < moves.length; i++) {\r\n        if (current_width + moves[i].length > max_width) {\r\n          if (moves[i].includes('{')) {\r\n            current_width = wrap_comment(current_width, moves[i])\r\n            continue\r\n          }\r\n        }\r\n        /* if the current move will push past max_width */\r\n        if (current_width + moves[i].length > max_width && i !== 0) {\r\n          /* don't end the line with whitespace */\r\n          if (result[result.length - 1] === ' ') {\r\n            result.pop()\r\n          }\r\n\r\n          result.push(newline)\r\n          current_width = 0\r\n        } else if (i !== 0) {\r\n          result.push(' ')\r\n          current_width++\r\n        }\r\n        result.push(moves[i])\r\n        current_width += moves[i].length\r\n      }\r\n\r\n      return result.join('')\r\n    },\r\n\r\n    load_pgn: function (pgn, options) {\r\n      // allow the user to specify the sloppy move parser to work around over\r\n      // disambiguation bugs in Fritz and Chessbase\r\n      var sloppy =\r\n        typeof options !== 'undefined' && 'sloppy' in options\r\n          ? options.sloppy\r\n          : false\r\n\r\n      function mask(str) {\r\n        return str.replace(/\\\\/g, '\\\\')\r\n      }\r\n\r\n      function parse_pgn_header(header, options) {\r\n        var newline_char =\r\n          typeof options === 'object' &&\r\n          typeof options.newline_char === 'string'\r\n            ? options.newline_char\r\n            : '\\r?\\n'\r\n        var header_obj = {}\r\n        var headers = header.split(new RegExp(mask(newline_char)))\r\n        var key = ''\r\n        var value = ''\r\n\r\n        for (var i = 0; i < headers.length; i++) {\r\n          var regex = /^\\s*\\[([A-Za-z]+)\\s*\"(.*)\"\\s*\\]\\s*$/\r\n          key = headers[i].replace(regex, '$1')\r\n          value = headers[i].replace(regex, '$2')\r\n          if (trim(key).length > 0) {\r\n            header_obj[key] = value\r\n          }\r\n        }\r\n\r\n        return header_obj\r\n      }\r\n\r\n      // strip whitespace from head/tail of PGN block\r\n      pgn = pgn.trim()\r\n\r\n      var newline_char =\r\n        typeof options === 'object' && typeof options.newline_char === 'string'\r\n          ? options.newline_char\r\n          : '\\r?\\n'\r\n\r\n      // RegExp to split header. Takes advantage of the fact that header and movetext\r\n      // will always have a blank line between them (ie, two newline_char's).\r\n      // With default newline_char, will equal: /^(\\[((?:\\r?\\n)|.)*\\])(?:\\s*\\r?\\n){2}/\r\n      var header_regex = new RegExp(\r\n        '^(\\\\[((?:' +\r\n          mask(newline_char) +\r\n          ')|.)*\\\\])' +\r\n          '(?:\\\\s*' +\r\n          mask(newline_char) +\r\n          '){2}'\r\n      )\r\n\r\n      // If no header given, begin with moves.\r\n      var header_string = header_regex.test(pgn)\r\n        ? header_regex.exec(pgn)[1]\r\n        : ''\r\n\r\n      // Put the board in the starting position\r\n      reset()\r\n\r\n      /* parse PGN header */\r\n      var headers = parse_pgn_header(header_string, options)\r\n      var fen = ''\r\n\r\n      for (var key in headers) {\r\n        // check to see user is including fen (possibly with wrong tag case)\r\n        if (key.toLowerCase() === 'fen') {\r\n          fen = headers[key]\r\n        }\r\n        set_header([key, headers[key]])\r\n      }\r\n\r\n      /* sloppy parser should attempt to load a fen tag, even if it's\r\n       * the wrong case and doesn't include a corresponding [SetUp \"1\"] tag */\r\n      if (sloppy) {\r\n        if (fen) {\r\n          if (!load(fen, true)) {\r\n            return false\r\n          }\r\n        }\r\n      } else {\r\n        /* strict parser - load the starting position indicated by [Setup '1']\r\n         * and [FEN position] */\r\n        if (headers['SetUp'] === '1') {\r\n          if (!('FEN' in headers && load(headers['FEN'], true))) {\r\n            // second argument to load: don't clear the headers\r\n            return false\r\n          }\r\n        }\r\n      }\r\n\r\n      /* NB: the regexes below that delete move numbers, recursive\r\n       * annotations, and numeric annotation glyphs may also match\r\n       * text in comments. To prevent this, we transform comments\r\n       * by hex-encoding them in place and decoding them again after\r\n       * the other tokens have been deleted.\r\n       *\r\n       * While the spec states that PGN files should be ASCII encoded,\r\n       * we use {en,de}codeURIComponent here to support arbitrary UTF8\r\n       * as a convenience for modern users */\r\n\r\n      var to_hex = function (string) {\r\n        return Array.from(string)\r\n          .map(function (c) {\r\n            /* encodeURI doesn't transform most ASCII characters,\r\n             * so we handle these ourselves */\r\n            return c.charCodeAt(0) < 128\r\n              ? c.charCodeAt(0).toString(16)\r\n              : encodeURIComponent(c).replace(/\\%/g, '').toLowerCase()\r\n          })\r\n          .join('')\r\n      }\r\n\r\n      var from_hex = function (string) {\r\n        return string.length == 0\r\n          ? ''\r\n          : decodeURIComponent('%' + string.match(/.{1,2}/g).join('%'))\r\n      }\r\n\r\n      var encode_comment = function (string) {\r\n        string = string.replace(new RegExp(mask(newline_char), 'g'), ' ')\r\n        return `{${to_hex(string.slice(1, string.length - 1))}}`\r\n      }\r\n\r\n      var decode_comment = function (string) {\r\n        if (string.startsWith('{') && string.endsWith('}')) {\r\n          return from_hex(string.slice(1, string.length - 1))\r\n        }\r\n      }\r\n\r\n      /* delete header to get the moves */\r\n      var ms = pgn\r\n        .replace(header_string, '')\r\n        .replace(\r\n          /* encode comments so they don't get deleted below */\r\n          new RegExp(`(\\{[^}]*\\})+?|;([^${mask(newline_char)}]*)`, 'g'),\r\n          function (match, bracket, semicolon) {\r\n            return bracket !== undefined\r\n              ? encode_comment(bracket)\r\n              : ' ' + encode_comment(`{${semicolon.slice(1)}}`)\r\n          }\r\n        )\r\n        .replace(new RegExp(mask(newline_char), 'g'), ' ')\r\n\r\n      /* delete recursive annotation variations */\r\n      var rav_regex = /(\\([^\\(\\)]+\\))+?/g\r\n      while (rav_regex.test(ms)) {\r\n        ms = ms.replace(rav_regex, '')\r\n      }\r\n\r\n      /* delete move numbers */\r\n      ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '')\r\n\r\n      /* delete ... indicating black to move */\r\n      ms = ms.replace(/\\.\\.\\./g, '')\r\n\r\n      /* delete numeric annotation glyphs */\r\n      ms = ms.replace(/\\$\\d+/g, '')\r\n\r\n      /* trim and get array of moves */\r\n      var moves = trim(ms).split(new RegExp(/\\s+/))\r\n\r\n      /* delete empty entries */\r\n      moves = moves.join(',').replace(/,,+/g, ',').split(',')\r\n      var move = ''\r\n\r\n      var result = ''\r\n\r\n      for (var half_move = 0; half_move < moves.length; half_move++) {\r\n        var comment = decode_comment(moves[half_move])\r\n        if (comment !== undefined) {\r\n          comments[generate_fen()] = comment\r\n          continue\r\n        }\r\n\r\n        move = move_from_san(moves[half_move], sloppy)\r\n\r\n        /* invalid move */\r\n        if (move == null) {\r\n          /* was the move an end of game marker */\r\n          if (TERMINATION_MARKERS.indexOf(moves[half_move]) > -1) {\r\n            result = moves[half_move]\r\n          } else {\r\n            return false\r\n          }\r\n        } else {\r\n          /* reset the end of game marker if making a valid move */\r\n          result = ''\r\n          make_move(move)\r\n        }\r\n      }\r\n\r\n      /* Per section 8.2.6 of the PGN spec, the Result tag pair must match\r\n       * match the termination marker. Only do this when headers are present,\r\n       * but the result tag is missing\r\n       */\r\n      if (result && Object.keys(header).length && !header['Result']) {\r\n        set_header(['Result', result])\r\n      }\r\n\r\n      return true\r\n    },\r\n\r\n    header: function () {\r\n      return set_header(arguments)\r\n    },\r\n\r\n    turn: function () {\r\n      return turn\r\n    },\r\n\r\n    move: function (move, options) {\r\n      /* The move function can be called with in the following parameters:\r\n       *\r\n       * .move('Nxb7')      <- where 'move' is a case-sensitive SAN string\r\n       *\r\n       * .move({ from: 'h7', <- where the 'move' is a move object (additional\r\n       *         to :'h8',      fields are ignored)\r\n       *         promotion: 'q',\r\n       *      })\r\n       */\r\n\r\n      // allow the user to specify the sloppy move parser to work around over\r\n      // disambiguation bugs in Fritz and Chessbase\r\n      var sloppy =\r\n        typeof options !== 'undefined' && 'sloppy' in options\r\n          ? options.sloppy\r\n          : false\r\n\r\n      var move_obj = null\r\n\r\n      if (typeof move === 'string') {\r\n        move_obj = move_from_san(move, sloppy)\r\n      } else if (typeof move === 'object') {\r\n        var moves = generate_moves()\r\n\r\n        /* convert the pretty move object to an ugly move object */\r\n        for (var i = 0, len = moves.length; i < len; i++) {\r\n          if (\r\n            move.from === algebraic(moves[i].from) &&\r\n            move.to === algebraic(moves[i].to) &&\r\n            (!('promotion' in moves[i]) ||\r\n              move.promotion === moves[i].promotion)\r\n          ) {\r\n            move_obj = moves[i]\r\n            break\r\n          }\r\n        }\r\n      }\r\n\r\n      /* failed to find move */\r\n      if (!move_obj) {\r\n        return null\r\n      }\r\n\r\n      /* need to make a copy of move because we can't generate SAN after the\r\n       * move is made\r\n       */\r\n      var pretty_move = make_pretty(move_obj)\r\n\r\n      make_move(move_obj)\r\n\r\n      return pretty_move\r\n    },\r\n\r\n    undo: function () {\r\n      var move = undo_move()\r\n      return move ? make_pretty(move) : null\r\n    },\r\n\r\n    clear: function () {\r\n      return clear()\r\n    },\r\n\r\n    put: function (piece, square) {\r\n      return put(piece, square)\r\n    },\r\n\r\n    get: function (square) {\r\n      return get(square)\r\n    },\r\n\r\n    ascii() {\r\n      var s = '   +------------------------+\\n'\r\n      for (var i = SQUARE_MAP.a8; i <= SQUARE_MAP.h1; i++) {\r\n        /* display the rank */\r\n        if (file(i) === 0) {\r\n          s += ' ' + '87654321'[rank(i)] + ' |'\r\n        }\r\n\r\n        /* empty piece */\r\n        if (board[i] == null) {\r\n          s += ' . '\r\n        } else {\r\n          var piece = board[i].type\r\n          var color = board[i].color\r\n          var symbol =\r\n            color === WHITE ? piece.toUpperCase() : piece.toLowerCase()\r\n          s += ' ' + symbol + ' '\r\n        }\r\n\r\n        if ((i + 1) & 0x88) {\r\n          s += '|\\n'\r\n          i += 8\r\n        }\r\n      }\r\n      s += '   +------------------------+\\n'\r\n      s += '     a  b  c  d  e  f  g  h'\r\n\r\n      return s\r\n    },\r\n\r\n    remove: function (square) {\r\n      return remove(square)\r\n    },\r\n\r\n    perft: function (depth) {\r\n      return perft(depth)\r\n    },\r\n\r\n    square_color: function (square) {\r\n      if (square in SQUARE_MAP) {\r\n        var sq_0x88 = SQUARE_MAP[square]\r\n        return (rank(sq_0x88) + file(sq_0x88)) % 2 === 0 ? 'light' : 'dark'\r\n      }\r\n\r\n      return null\r\n    },\r\n\r\n    history: function (options) {\r\n      var reversed_history = []\r\n      var move_history = []\r\n      var verbose =\r\n        typeof options !== 'undefined' &&\r\n        'verbose' in options &&\r\n        options.verbose\r\n\r\n      while (history.length > 0) {\r\n        reversed_history.push(undo_move())\r\n      }\r\n\r\n      while (reversed_history.length > 0) {\r\n        var move = reversed_history.pop()\r\n        if (verbose) {\r\n          move_history.push(make_pretty(move))\r\n        } else {\r\n          move_history.push(move_to_san(move, generate_moves({ legal: true })))\r\n        }\r\n        make_move(move)\r\n      }\r\n\r\n      return move_history\r\n    },\r\n\r\n    get_comment: function () {\r\n      return comments[generate_fen()]\r\n    },\r\n\r\n    set_comment: function (comment) {\r\n      comments[generate_fen()] = comment.replace('{', '[').replace('}', ']')\r\n    },\r\n\r\n    delete_comment: function () {\r\n      var comment = comments[generate_fen()]\r\n      delete comments[generate_fen()]\r\n      return comment\r\n    },\r\n\r\n    get_comments: function () {\r\n      prune_comments()\r\n      return Object.keys(comments).map(function (fen) {\r\n        return { fen: fen, comment: comments[fen] }\r\n      })\r\n    },\r\n\r\n    delete_comments: function () {\r\n      prune_comments()\r\n      return Object.keys(comments).map(function (fen) {\r\n        var comment = comments[fen]\r\n        delete comments[fen]\r\n        return { fen: fen, comment: comment }\r\n      })\r\n    },\r\n  }\r\n}\r\n"],
  "mappings": ";AA2BA,IAAM,UAAU;AAEhB,IAAM,mBACJ;AAEF,IAAM,sBAAsB,CAAC,OAAO,OAAO,WAAW,GAAG;AAEzD,IAAM,eAAe;AAAA,EACnB,GAAG,CAAC,IAAI,IAAI,IAAI,EAAE;AAAA,EAClB,GAAG,CAAC,KAAK,KAAK,KAAK,GAAG;AACxB;AAEA,IAAM,gBAAgB;AAAA,EACpB,GAAG,CAAC,KAAK,KAAK,KAAK,KAAK,IAAI,IAAI,IAAI,EAAE;AAAA,EACtC,GAAG,CAAC,KAAK,KAAK,IAAI,EAAE;AAAA,EACpB,GAAG,CAAC,KAAK,GAAG,IAAI,EAAE;AAAA,EAClB,GAAG,CAAC,KAAK,KAAK,KAAK,GAAG,IAAI,IAAI,IAAI,EAAE;AAAA,EACpC,GAAG,CAAC,KAAK,KAAK,KAAK,GAAG,IAAI,IAAI,IAAI,EAAE;AACtC;AAGA,IAAM,UAAU;AAAA,EACd;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAK;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAE;AAAA,EAAI;AAAA,EAC/C;AAAA,EAAE;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAK;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAE;AAAA,EAAI;AAAA,EAAG;AAAA,EAC/C;AAAA,EAAG;AAAA,EAAE;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAK;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAE;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAC/C;AAAA,EAAG;AAAA,EAAG;AAAA,EAAE;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAK;AAAA,EAAG;AAAA,EAAG;AAAA,EAAE;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAC/C;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAE;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAK;AAAA,EAAG;AAAA,EAAE;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAC/C;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAE;AAAA,EAAI;AAAA,EAAG;AAAA,EAAK;AAAA,EAAE;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAC/C;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAE;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAChD;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAK;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAC/C;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAE;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAC/C;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAE;AAAA,EAAI;AAAA,EAAG;AAAA,EAAK;AAAA,EAAE;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAC/C;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAE;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAK;AAAA,EAAG;AAAA,EAAE;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAC/C;AAAA,EAAG;AAAA,EAAG;AAAA,EAAE;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAK;AAAA,EAAG;AAAA,EAAG;AAAA,EAAE;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAC/C;AAAA,EAAG;AAAA,EAAE;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAK;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAE;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAC/C;AAAA,EAAE;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAK;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAE;AAAA,EAAI;AAAA,EAAG;AAAA,EAChD;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAK;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAE;AAC9C;AAGA,IAAM,OAAO;AAAA,EACV;AAAA,EAAK;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAG;AAAA,EAAK;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAG;AAAA,EAAI;AAAA,EAC3D;AAAA,EAAG;AAAA,EAAK;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAG;AAAA,EAAK;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAG;AAAA,EAAK;AAAA,EAAG;AAAA,EAC3D;AAAA,EAAI;AAAA,EAAG;AAAA,EAAK;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAG;AAAA,EAAK;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAG;AAAA,EAAK;AAAA,EAAI;AAAA,EAAG;AAAA,EAC3D;AAAA,EAAI;AAAA,EAAI;AAAA,EAAG;AAAA,EAAK;AAAA,EAAI;AAAA,EAAI;AAAA,EAAG;AAAA,EAAK;AAAA,EAAI;AAAA,EAAI;AAAA,EAAG;AAAA,EAAK;AAAA,EAAI;AAAA,EAAI;AAAA,EAAG;AAAA,EAC3D;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAG;AAAA,EAAK;AAAA,EAAI;AAAA,EAAG;AAAA,EAAK;AAAA,EAAI;AAAA,EAAG;AAAA,EAAK;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAG;AAAA,EAC3D;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAG;AAAA,EAAK;AAAA,EAAG;AAAA,EAAK;AAAA,EAAG;AAAA,EAAK;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAG;AAAA,EAC3D;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAG;AAAA,EAAI;AAAA,EAAI;AAAA,EAAK;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAG;AAAA,EAC3D;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAG;AAAA,EAAI;AAAA,EAAK;AAAA,EAAG;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAC3D;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAE;AAAA,EAAI;AAAA,EAAI;AAAA,EAAM;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAG;AAAA,EAC3D;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAE;AAAA,EAAM;AAAA,EAAE;AAAA,EAAM;AAAA,EAAE;AAAA,EAAM;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAG;AAAA,EAC3D;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAE;AAAA,EAAM;AAAA,EAAI;AAAA,EAAE;AAAA,EAAM;AAAA,EAAI;AAAA,EAAE;AAAA,EAAM;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAG;AAAA,EAC3D;AAAA,EAAI;AAAA,EAAI;AAAA,EAAE;AAAA,EAAM;AAAA,EAAI;AAAA,EAAI;AAAA,EAAE;AAAA,EAAM;AAAA,EAAI;AAAA,EAAI;AAAA,EAAE;A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",
  "names": ["fen", "board", "moves", "i", "len", "move_string", "move", "header", "options", "newline_char", "headers", "key"]
}
